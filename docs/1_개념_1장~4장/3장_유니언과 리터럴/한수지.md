## ✨ 3장. 유니언과 리터럴

상수를 제외한 모든 것은 변한다.
(시간이 지나면서 값도 변할 수 있다.)

**유니언과 내로잉**은 다른 주요 프로그래밍 언어에서는 불가능하지만 **타입스크립트**에서 가능한 **코드 정보에 입각한 추론을 해내는 개념**이다.
(타입스크립트가 해당 값을 바탕으로 추론을 수행하는 핵심개념)

- **유니언**: 값에 허용된 **타입을 두 개 이상의 가능한 타입으로 확장**하는 것

- **내로잉**: 값에 허용된 **타입을 하나 이상의 가능한 타입이 되지 않도록 좁히는 것**

---

### 📌 3-1. 유니언 타입

> 유니언 타입이란, 값에 허용된 타입을 두 개 이상의 가능한 타입으로 **확장**하는 것을 말한다.

```js
// 변수 foo의 타입은 undefined 이거나 string 타입이다.
let foo = Math.Random() > 0.5 ? undefined : "Foo";
```

'이거 혹은 저거'와 같은 `or`의 개념으로 타입을 2개 이상 허용하는 것을 **유니언**이라고 한다.

```ts
let foo: string | undefined = Math.random() > 0.5 ? undefined : "Foo";
```

> 유니언 타입은 가능한 값 또는 **구성요소 사이**에 `|`**수직선 연산자를 사용**하여 유니언 타입을 나타낸다.

#### 🔎 유니언 타입 선언

**변수에 초깃값**이 있더라도 변수에 대한 **명시적 타입 애너테이션을 제공하는 것이 유용**할때 유니언 타입을 사용한다.

```ts
let foo: string | null = null;
if (Math.random() > 0.5) {
  foo = "Foo";
}
```

유니언 타입 선언의 순서는 중요하지 않다.
위 코드에서 `string | null` 은 `null | string`과 똑같다.

#### 🔎 유니언 속성

값이 유니언 타입일때, 타입스크립트는 유니언으로 선언한 **모든 가능한 타입에 존재하는 멤버 속성에만 접근할 수 있다.**

(유니언 외의 타입에 접근하려고 하면 오류가 발생)

```ts
// foo의 타입은 string이거나 number이다.
// 즉, foo가 string일때 number속성에 접근하려고 하면 에러가 발생한다.
// 반대로 foo가 number일때 string속성에 접근하려고 하면 에러가 발생한다.
let foo = Math.random() > 0.5 ? "Foo" : 100;
```

모든 유니언 타입에 존재하지 않는 **속성에 대한 접근을 제한하는 것은 안전 조치에 해당**한다.

객체가 어떤 속성을 포함한 타입으로 확실하게 알려지지 않는다면, 타입스크립트는 안전하지 않다고 여기게 된다.

따라서, **유니언 타입으로 정의된 여러 타입중 하나의 타입으로 된 값의 속성을 사용하려면** 코드에서 값이 보다 **구체적인 타입 중 하나라는 것을 내로잉을 통해 알려야 한다.**

---

### 📌 3-2. 내로잉

> **내로잉**이란, 값에 허용된 **타입을 하나 이상의 가능한 타입이 되지 않도록 좁히는 것**을 말한다.

값이 정의, 선언 혹은 이전에 유추된 것 보다 `더 구체적인 타입임을 코드에서 유추하는 것`이다.

**내로잉은 타입 가드를 통해 타입을 좁힐 수 있다.**

- 타입 가드: `타입을 좁히는 데 사용`할 수 있는 `논리적 검사`를 말한다.

#### 🔎 값 할당을 통한 내로잉

```ts
let foo: number | string = "Foo";

foo.toUpperCage(); // OK
```

변수에 값을 직접 할당하면 타입스크립트는 변수의 타입을 할당된 값의 타입으로 좁힌다.

초기에 `number | string`으로 선언하였지만, 바로 'Foo'라는 값이 할당된 이후 타입스크립트는 해당 변수가 string이라는 것을 알아차리게 되었다.

> 변수에 유니언 타입 애너테이션이 명시되고 초깃값이 주어질 때 값 할당 내로잉이 작동한다.

변수가 나중에 유니언 타입으로 선언된 타입 중 하나의 값을 받을 수 있지만,
처음에는 초기에 할당된 값의 타입으로 시작한다는 것을 이해한다.

#### 🔎 조건 검사를 통한 내로잉

일반적으로 타입스크립트에서는 변수가 알려진 값과 같은지 확인하는 **if문을 통해 변수의 값을 좁히는 방법을 사용**한다.

```ts
let foo = Math.random() > 0.5 ? "Foo" : 50;

if (foo === "Foo") {
  foo.toUpperCase(); // OK
}
```

조건부 로직으로 내로잉 할때, 타입스크립트 타입 검사 로직은 훌륭한 자바스크립트 코딩 패턴을 미러링해 구현한다.

#### 🔎 typeof 검사를 통한 내로잉

타입스크립트는 typeof 연산자를 사용하여 타입을 검사할 수 있다.
또한, `!`를 사용한 논리적 부정과 else문, 삼항연산자에도 잘 작동한다.

```ts
// typeof 연산자를 사용한 타입 검사
let foo = Math.random() > 0.5 ? "Foo" : 50;

if (typeof foo === "string") {
  foo.toUpperCase(); // OK: string
}

// 논리적 부정과 else문을 통한 검사
if (!(typeof foo === "string")) {
  foo.toFixed(); // OK: number
} else {
  foo.toUpperCase(); // OK: string
}

// 삼항연산자에서의 검사
typeof foo === "string"
  ? foo.toUpperCase() // OK: string
  : foo.toFixed(); // OK: number
```

어떤 방법으로 작성하든 **typeof 검사는 타입을 좁히기 위해 자주 사용하는 방법**이다.

---

### 📌 3-3. 리터럴 타입

> 리터럴 타입이란 좀 더 **구체적인 버전의 원시타입**이다.

```ts
const foo = "Han";
```

해당 변수의 타입은 string으로 보이지만, 더 구체적으로는 'Han'이라고 볼 수 있다.
이것이 바로 리터럴 타입의 개념이다.

**원시타입 값 중 어떤것이 아닌 특정 원싯값으로 알려진 타입이 리터럴 타입이다.**

string 원시타입에는 다양한 문자들이 포함될 수 있지만, 리터럴 타입은 해당 범위를 구체적으로 압축시킨 것이라고 생각하면 좋다.

**일반적인 타입스크립트 코드에서 발견할 수 있는 리터럴 타입**

- boolean: true | false
- null과 undefined: 둘 다 자기 자신, 즉 오직 하나의 리터럴 값만 가진다.
- number: 0 | 1 | 2 ... | 0.1 | 0.2 | ...
- string: '' | 'a' | 'b' | ... | 'aa' | ...

유니언 타입과 애너테이션에서는 리터럴과 원시타입을 섞어서 사용할 수 있다.

```ts
// 원시타입 number이거나 리터럴타입 Foo 또는 Boo가 될 수 있다.
let foo: number | "Foo" | "Boo";
```

#### 🔎 리터럴 할당 가능성

```ts
let foo = ""; // 타입: string
```

리터럴 타입은 그 값이 해당하는 원시 타입에 할당할 수 있다.
모든 특정 리터럴 문자열은 여전히 string 타입이기 때문이다.

---

### 📌 3-4. 엄격한 null 검사 (strict null checking)

리터럴로 좁혀진 유니언의 힘은 타입스크립트에서 엄격한 null 검사라 부르는 타입 시스템 영역인 잠재적으로 정의되지 않은 undefined값으로 작업할 때 특히 이점이 있다.

타입스크립트는 strictNullChecks을 사용하여 십억 달러의 실수를 줄이기 위해 노력하고 있다.

#### 🔎 십억 달러의 실수

십억 달러의 실수는 다른 타입이 필요한 위치에서 null 값을 사용하도록 허용하는 많은 타입 시스템을 가리키는 업계 용어이다.

null 검사가 없는 언어에서는 다음과 같이 다른 타입의 변수에 null을 할당하는 것이 허용된다.

```ts
const name: string = null;
```

타입스크립트 컴파일러는 실행 방식을 변경할 수 있는 다양한 옵션을 제공한다.
가장 유용한 옵션 중 하나인 strictNullChecks 를 활성화 하는 것이 타입스크립트의 모범 사례이다.

이렇게 해야 코드에서 발생하게 될 잠재적인 충돌을 방지하고 안전하다고 간주된다.

#### 🔎 참 검사를 통한 내로잉

자바스크립트에서 true 또는 truthy는 `&&` 연산자 또는 if 문처럼 boolean 문맥에서 true로 간주된다.
(자바스크립트의 falsy 값들을 제외한 모든 코드는 truthy이다.)

- 자바스크립트의 falsy 값들 : 0, -0, 0n, '', null, undefined, NaN

타입스크립트는 잠재적인 값 중 truthy로 확인된 일부에 한해서만 변수의 타입을 좁힐 수 있다.

논리연산자 && 와 ? 는 참 여부를 검사하는 일도 잘 수행하지만, 참 여부 확인 외에 다른 기능은 제공하지 않는다. (주의해야할 점)

따라서 `string | undefined`값에 대해 알고있는 것이 falsy라면 그것이 빈 문자열인지 undefined인지 알수가 없다.

#### 🔎 초기값이 없는 변수

자바스크립트에서 초깃값이 없는 변수는 기본적으로 undefined이다.
이는 타입 시스템에서 극단적인 경우를 나타내기도 한다.

변수에 값이 할당하기 전에 속성 중 하나에 접근하려고 한다면 오류가 발생한다.

```ts
let foo: string | undefined;
foo?.length; // OK

foo = "Foo";
foo.length; // OK
```

따라서, 변수 타입에 `| undefined`를 추가하면 유효한 타입이기 때문에 사용 전에는 정의할 필요가 없음을 타입스크립트에 나타낸다.

---

### 📌 3-5. 타입 별칭

> 타입별칭이란 타입스크립트에서 재사용하는 타입에 더 쉬운 이름을 할당하는 것이다.

타입 별칭은 `type 새로운이름 = 타입`형태를 갖는다.
편의상 타입 별칭은 파스칼 케이스로 작성한다.

```ts
type ValueType = string | number;

let foo: ValueType;
let boo: ValueType;
```

타입스크립트의 단점 중 하나는 가독성이 좋지 않다는 점이다.
타입이 긴 형태의 불편한 가독성을 가지고 있다면 이를 타입별칭을 이용하여 분리하여 적용할 수 있다.

#### 🔎 타입 별칭은 자바스크립트가 아닙니다

타입별칭은 타입 애너테이션과 마찬가지로 자바스크립트가 아니기 때문에, 순전히 타입스크립트 타입 시스템에만 존재한다. (개발시에만 존재)

따라서 자바스크립트로 컴파일될때 해당 타입 코드들은 함께 컴파일 되지않고 날라간다.

```ts
type Props = string | undefined;

console.log(Props); // Error
```

타입스크립트는 런타임에 존재하지 않는 항목에 접근하려고 하면 타입 오류로 알려준다.

#### 🔎 타입 별칭 결합

타입 별칭은 **다른 타입 별칭을 참조할 수 있다.**

유니언 타입인 타입 별칭 내에 또 다른 유니언 타입인 타입 별칭을 포함하고 있다면 이를 참조하는 것이 유용하다.

```ts
type Id = number | string;

type IdMaybe = Id | undefined | null;

// 순서에 상관없음
type IdMaybe = Id | undefined | null; // OK
type Id = number | string;
```

사용 순서대로 타입 별칭을 선언할 필요는 없으며, 파일 내에서 타입 별칭을 먼저 선언하고 참조할 타입 별칭을 나중에 선언해도 된다.

---

### 📌 3-6. 마치며

3장에서 공부한 내용

구조화된 코드에서 타입 시스템이 더 구체적인 타입을 유추하는 방법

- 유니언 타입으로 두 개 이상의 타입 중 하나일 수 있는 값을 나타내는 방법
- 타입 애너테이션으로 유니언 타입을 명시적으로 표현하는 방법
- 타입 내로잉으로 값의 가능한 타입을 좁히는 방법
- 리터럴 타입의 const 변수와 let 변수의 차이점
- 타입스크립트가 엄격한 null 검사를 처리하는 방법
- 존재하지 않을 수 있는 값을 나타내는 명시적인 `: undefined`
- 할당되지 않은 변수를 위한 암묵적인 `: undefined`
- 반복적으로 사용하고 입력이 긴 유니언 타입을 타입 별칭에 저장하는 방법
