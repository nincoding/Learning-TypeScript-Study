## ✨ 2장. 타입 시스템

### 📌 2-1. 타입의 종류

> 타입은 자바스크립트에서 다루는 값의 형태에 대한 설명이다.

- 형태: 값에 존재하는 속성과 메서드 그리고 내장되어 있는 `typeof`연산자가 설명하는 것을 의미한다.

**타입 스크립트의 가장 기본적인 타입**

타입 스크립트의 가장 기본적인 타입은 자바스크립트의 일곱 가지 기본 원시 타입과 동일하다.

![](https://velog.velcdn.com/images/ninto_2/post/09cca03d-f640-44bc-a387-9c7c63689769/image.png)

숫자타입, 문자열 타입, 불리언 타입, undefined타입, null타입, symbol타입, 그리고 bigint 타입이 추가되었다.

#### 🔎 타입 시스템

> 타입 시스템은 프로그래밍 언어가 프로그램에서 가질 수 있는 타입을 이해하는 방법에 대한 규칙 집합이다.

**타입스크립트의 타입 시스템 작동 순서**

1. 코드를 읽고 존재하는 모든 타입과 값을 이해한다.
2. 각 값이 초기 선언에서 가질 수 있는 타입을 확인한다.
3. 각 값이 추후 코드에서 어떻게 사용될 수 있는지 모든 방법을 확인한다.
4. 값의 사용법이 타입과 일치하지 않으면 사용자에게 오류를 표시한다.

```ts
// 오류인 코드 예시
let firstName = "foo";
firstName.length(); // Error
```

**타입스크립트의 오류를 표시하는 순서**

1. 코드를 읽고 firstName변수를 이해한다.
2. 초기값 'foo' 을 확인하고 firstName변수의 타입을 string으로 결론짓는다.
3. firstName변수의 length가 함수처럼 호출되는 코드를 확인한다.
4. 오류를 표시한다.

#### 🔎 오류 종류

> 타입스크립트의 대표적인 오류는 구문 오류와 타입 오류이다.

- 구문 오류 : 타입 스크립트가 자바스크립로 변환 되는 것을 차단한 경우

구문 오류는 타입스크립트가 코드로 이해할 수 없는 잘못된 구문을 감지 할 때 발생한다.

- 타입 오류 : 타입 검사기에 따라 일치하지 않는 것이 감지된 경우

타입오류는 타입스크립트의 타입 검사기가 프로그램의 타입에서 오류를 감지했을 때 발생한다.

---

### 📌 2-2. 할당 가능성

> 할당 가능성이란, 타입스크립트에서 함수 호출이나 변수에 값을 제공할 수 있는지 여부를 확인하는 것이다. (전달된 값이 예상된 타입으로 할당 가능한지 여부를 확인함)

**타입스크립트는 변수의 초깃값을 읽고 해당 변수가 허용되는 타입을 결정한다.**

만약, 나중에 해당 변수에 새로운 값이 할당되면 **새롭게 할당된 값의 타입이 변수의 타입과 동일한지 확인**한다.

타입스크립트는 `변수에 다른 타입의 값이 할당되면 타입 오류가 발생한다.`

#### 🔎 할당 가능성 오류 이해하기

```
// 할당이 불가능할 때 나오는 오류메세지
Type...is not assignable to type...
```

---

### 📌 2-3. 타입 애너테이션

> 타입 애너테이션이란, 타입스크립트가 초깃값을 할당하지 않고도 변수의 타입을 선언할 수 있는 구문이다.

**타입 애너테이션의 구조**

```ts
// 타입 애너테이션은 콜론(:) 뒤에, 타입이름을 기재한다.
let name: string;
name = "foo";
```

타입 애너테이션은 변수 이름 뒤에 배치되며, 콜론(`:`)과 타입 이름을 차례대로 기재한다.

타입 애너테이션은 타입스크립트에만 존재하며, 런타임 코드에 영향을 주지 않고, 유효한 자바스크립트 구문도 아니다.

만약 tsc 명령어를 실행하여 자바스크립트 코드로 컴파일하면 해당 코드는 삭제된다.

타입 애너테이션으로 타입을 정의하면, 정의된 타입 외의 다른 타입들을 재할당 시에 모두 타입 오류를 발생시킨다.

- **타입스크립트의 `any`타입**

> 초기 타입을 유추할 수 없는 변수는 `진화하는 any`라고 부른다.

변수에 초기값이 없는 경우라도, 타입스크립트는 나중에 사용할 변수의 초기 타입을 파악하려고 시도하지 않는다.

**변수에 초기값이 없는 경우, 기본적으로 변수를 암묵적인 `any`타입으로 간주한다.**

`any`타입이란 세상의 모든 것이 될 수 있음을 나타낸다.

특정 타입을 강제하는 대신 새로운 값이 할당될 때 마다 변수 타입에 대한 이해를 발전시킨다.

> 일반적으로 any타입을 사용해 any타입으로 진화하는 것을 허용하게 되면 타입스크립트의 타입 검사 목적을 부분적으로 쓸모없게 만든다.

`any`타입을 가진 값에는 타입스크립트의 타입 검사 기능을 잘 적용할 수 없다.

#### 🔎 불필요한 타입 애너테이션

타입 애너테이션은 타입스크립트가 자체적으로 수집할 수 없는 정보를 타입스크립트에 제공할 수 있다.

하지만, 타입을 즉시 유추할 수 있는 경우에도 타입 애너테이션을 사용한다면
이는 타입을 중복으로 유추하는 것이다.

```ts
let firstName: string = "foo"; // 타입 시스템은 변경되지 않음
```

firstName이라는 변수에 문자타입 값을 바로 할당하였기에, 타입 애너테이션을 하지 않아도 해당 변수는 string 타입이라는 것을 추론해낼 수 있다.

> 아무것도 변하지 않는 변수에는 타입 애너테이션을 추가하지 않는 것이 지향된다.

---

### 📌 2-4. 타입 형태

타입스크립트는 변수에 할당된 값이 원래 타입과 일치하는지 확인하는 것 이상을 수행한다.

타입스크립트는 객체에 어떤 멤버 속성이 존재하는지 알고 있기 때문에, 변수의 속성에 접근하려고 한다면 **해당 변수의 타입에 접근하려는 속성이 존재하는지 확인**한다.

#### 🔎 모듈

ECMAScript 2015에는 파일 간에 import, export 구문을 표준화 하기 위해 ECMAScript Modules(ESM)이 추가되었다.

- 모듈: export 또는 import가 있는 파일
- 스크립트: 모듈이 아닌 모든 파일

타입스크립트는 최신 모듈 파일을 기존 파일과 함께 실행할 수 있다.

```ts
// a.ts
export const shared = "Cher";

// b.ts
export const shared = "Cher";

// c.ts
import { shared } from "./a";

export const shared = "Cher"; // Error
```

a와 b 파일 모두 모듈이고, 이름이 동일한 변수를 문제없이 내보낸다.
하지만 c파일에서 가져온 변수와 c파일 내부에서 정의된 변수의 이름이 충돌되어 타입오류가 발생한다.

```ts
// a.ts
const shared = "Cher";

// b.ts
const shared = "Cher";
```

a와 b 파일 모두 export 또는 import가 없기 때문에 스크립트로 간주된다.

> 스크립트 파일에 선언된 변수는 다른 스크립트 파일에 선언된 변수와 동일한 이름을 가질 수 없다. (전역 스코프로 간주되기 때문)

타입스크립트는 CommonJS와 같은 이전 모듈을 사용해서 작성된 타입스크립트 파일의 import, export 형태는 인식하지 못한다.

일반적으로 CommonJS 스타일의 require함수에서 반환된 값을 any타입으로 인식한다.

---

### 📌 2-5. 마치며

2장에서 공부한 내용

(타입스크립트의 타입 시스템이 어떻게 작동되는지)

- 타입과 타입스크립트가 인식하는 원시 타입 이해
- 타입시스템과 타입스크립트의 타입 시스템이 코드를 이해하는 방법
- 타입 오류와 타입 구문 오류의 차이점
- 유추된 변수 타입과 변수 할당 가능성
- 타입 애너테이션으로 변수 타입을 명시적으로 선언하고, any 타입의 진화 방지하기
- 타입 형태에서 객체 멤버 확인하기
- 스크립트 파일과는 다른 ECMAScript 모듈 파일의 선언 스코프
